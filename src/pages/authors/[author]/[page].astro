---
// warning: This file is overwritten by Astro Accelerator

// For listing all articles in this folder
import { PostFiltering, PostOrdering, PostPaging, Cache, Markdown, Posts } from 'astro-accelerator-utils';
import type { Frontmatter } from 'astro-accelerator-utils/types/Frontmatter';
import { Translations, Lang } from '@util/Languages';
import type { Page, MarkdownInstance } from 'astro';
import { SITE } from '@config';
import Default from '@layouts/Default.astro';
import ArticleList from '@components/ArticleList.astro';
import Paging from '@components/Paging.astro';

const lang = SITE.default.lang;
const currentUrl = new URL(Astro.request.url);
const slug = currentUrl.pathname.split('/')[2];

const markdown = new Markdown();
const cache = new Cache(SITE.cacheMaxAge);
const posts = new Posts(cache);

const author = posts.all()
  .filter(PostFiltering.isAuthor)
  .filter(x => x.url?.split('/')[2] == slug)[0];


// Props
type Props = {
  page: Page<MarkdownInstance<Record<string, any>>>;
  headings: { depth: number; slug: string; text: string; }[];
  pubDate: Date;
};
const { page, headings, pubDate } = Astro.props as Props;

const authorFrontmatter = {
  ...author.frontmatter,
  pubDate: pubDate
} as Frontmatter;

const text = author.frontmatter.summary.replace('\n', '\n\n');
const authorText = markdown.getHtmlFrom(text);

// Language
const _ = Lang(lang);

// Logic
type AuthorData = {
  posts: MarkdownInstance<Record<string, any>>[];
  authors: string[];
}

export async function getData() {
  const sourcePosts = await Astro.glob('../../**/*.md');
  const data: AuthorData = { posts: [], authors: []};

  data.posts = sourcePosts
    .filter(PostFiltering.isListable)
    .sort(PostOrdering.sortByPubDateDesc);

    data.posts.forEach(p => {
    const auths: string[] = p.frontmatter.authors ?? [];
    if (auths.length == 0) {
      console.log('No authors found', p.url);
    }
    auths.forEach(a => {
      if (!data.authors.includes(a)) {
        data.authors.push(a);
      }
    });
  });
    
  return data;
}

export async function getStaticPaths({ paginate }: any) {
  let data = await getData();

  return data.authors.map(a => {
    const filtered = data.posts.filter(p => {
      const auths: string[] = p.frontmatter.authors ?? [];
      return auths.includes(a);
    });
    return paginate(filtered, { 
        params: { author: a.toLowerCase() },
        props: { pubDate: filtered[0].frontmatter.pubDate },
        pageSize: SITE.pageSize 
    });
  }).flat();
}

// Page Links
const pageLinks = PostPaging.getPageLinks(SITE.pageLinks, page.lastPage, page.currentPage, page.url.current);
---
<Default frontmatter={ authorFrontmatter } headings={ headings }>
  <Fragment set:html={ authorText } />
  <h2>{ _(Translations.articles.page_title).replace('{n}', page.currentPage.toString())}</h2>
  <ArticleList lang={ lang } posts={ page.data } />
  <Paging lang={ lang } page={ page } pageLinks={ pageLinks } />
</Default>