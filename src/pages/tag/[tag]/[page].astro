---
// warning: This file is overwritten by Astro Accelerator

// For listing by frontmatter.tags
import { Translations, Lang } from '@util/Languages';
import type { Page, MarkdownInstance } from 'astro';
import { SITE, Frontmatter } from '@config';
import { getPageLinks } from '@util/PageLinks';
import {Cache, PostFiltering, PostOrdering } from 'astro-accelerator-utils';
import Default from 'src/layouts/Default.astro';
import ArticleList from '@components/ArticleList.astro';
import Paging from '@components/Paging.astro';

const lang = SITE.default.lang;
const currentUrl = new URL(Astro.request.url);
const slug = currentUrl.pathname.split('/')[3];

// Props
type Props = {
  title: string;
  page: Page<MarkdownInstance<Record<string, any>>>;
  headings: { depth: number; slug: string; text: string; }[];
  pubDate: Date;
};
const { title, page, headings, pubDate } = Astro.props as Props;

const frontmatter: Frontmatter = {
  layout: 'src/layouts/Default.astro',
  title: title,
  keywords: `${slug},articles,astro,accelerator`,
  description: `Astro Accelerator ${slug} articles.`,
  pubDate: pubDate,
  robots: 'noindex, follow'
};

// Language
const _ = Lang(lang);

// Logic
type CacheData = {
  posts: MarkdownInstance<Record<string, any>>[];
  tags: string[];
}

export async function getCacheData() {
  const key = 'pages_articles_[tag]_[page]';

  let cacheData: CacheData = await Cache.getItem(key);

  if (cacheData == null) {
    // This uses a relative glob, so we only look in the current collection
    const sourcePosts = await Astro.glob('../../**/*.md');
    
    cacheData = { posts: [], tags: []};

    cacheData.posts = sourcePosts
      .filter(PostFiltering.isListable)
      .sort(PostOrdering.sortByPubDateDesc);

    cacheData.posts.forEach(p => {
      const auths: string[] = p.frontmatter.tags ?? [];
      if (auths.length == 0) {
        console.log('No categories found', p.url);
      }
      auths.forEach(a => {
        if (!cacheData.tags.includes(a)) {
          cacheData.tags.push(a);
        }
      });
    });

    await Cache.setItem(key, cacheData);
  }

  return cacheData;
}

export async function getStaticPaths({ paginate }: any) {
  let data = await getCacheData();

  return data.tags.map(t => {
    const filtered = data.posts.filter(p => {
      const tags: string[] = p.frontmatter.tags ?? [];
      return tags.includes(t);
    });
    return paginate(filtered, {
      params: { tag: t.toLowerCase().replace(/ /g, '-') },
      props: { title: t, pubDate: filtered[0].frontmatter.pubDate },
      pageSize: SITE.pageSize 
    });
  }).flat();
}

// Page Links
const pageLinks = getPageLinks(SITE.pageLinks, page.lastPage, page.currentPage, page.url.current);
---
<Default frontmatter={ frontmatter } headings={ headings }>
  <h2>{ _(Translations.articles.page_title).replace('{n}', page.currentPage.toString())}</h2>
  <ArticleList lang={ lang } posts={ page.data } />
  <Paging lang={ lang } page={ page } pageLinks={ pageLinks } />
</Default>