---
import type { MarkdownInstance } from "astro";
import { getItem, setItem } from '@util/Cache.astro';
import { isAuthor } from '@util/PageTypeFilters.astro';

export type PagePredicate = (value: MarkdownInstance<Record<string, any>>, index: number, array: MarkdownInstance<Record<string, any>>[]) => boolean;

export async function getPages (filter?: PagePredicate | null): Promise<MarkdownInstance<Record<string,any>>[]> {
    const key = 'PageQueries__getPages';
    let allPages = await getItem(key);

    if (allPages == null) {
        allPages = await Astro.glob("../pages/**/*.md");
        await setItem(key, allPages);
    }

    if (filter == null) {
        return allPages;
    }

    return allPages.filter(filter);
}

export async function getTopLevelPages (filter?: PagePredicate | null): Promise<MarkdownInstance<Record<string,any>>[]> {
    const key = 'PageQueries__getTopLevelPages';
    let allPages = await getItem(key);

    if (allPages == null) {
        allPages = await Astro.glob("../pages/*.md");
        await setItem(key, allPages);
    }

    if (filter == null) {
        return allPages;
    }

    return allPages.filter(filter);
}

export async function getAuthorInfo(slug: string) {
    const cacheKey = 'Global__author_info';
    
    let authorInfo = await getItem(cacheKey);

    if (authorInfo == null) {
        const allPages = await Astro.glob("../pages/**/*.md");
        const author = allPages
            .filter(isAuthor)
            .filter(x => x.url?.split('/')[2] == slug)[0];

        authorInfo = {
            frontmatter: author.frontmatter,
            content: author.compiledContent()
        };
  
      await setItem(cacheKey, authorInfo);
    }

    return authorInfo;
}

export async function getTaxonomy() {
    const cacheKey = 'Global__taxonomy';

    type Taxonomy = { 
        tags: { [key: string]: number }, 
        categories: { [key: string]: number }
    };
    
    let taxonomy: Taxonomy = await getItem(cacheKey);

    if (taxonomy == null) {
        const allPages = await getPages();

        taxonomy = {
            tags: {},
            categories: {}
        };

        allPages.forEach((p) => {
            p.frontmatter.tags && p.frontmatter.tags.forEach(t => {
                taxonomy.tags[t] = (taxonomy.tags[t] ?? 0) + 1;
            });

            p.frontmatter.categories && p.frontmatter.categories.forEach(c => {
                taxonomy.categories[c] = (taxonomy.categories[c] ?? 0) + 1;
            });
        });

        await setItem(cacheKey, taxonomy);
    }

    return taxonomy;
}
---