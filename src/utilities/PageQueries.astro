---
import type { MarkdownInstance } from "astro";
import { getItem, setItem } from '@util/Cache.astro';
import { isAuthor } from '@util/PageTypeFilters.astro';

export type PagePredicate = (value: MarkdownInstance<Record<string, any>>, index: number, array: MarkdownInstance<Record<string, any>>[]) => boolean;

export async function getPages (filter?: PagePredicate | null): Promise<MarkdownInstance<Record<string,any>>[]> {
    const key = 'PageQueries__getPages';
    let allPages = await getItem(key);

    if (allPages == null) {
        allPages = await Astro.glob("../pages/**/*.md");
        await setItem(key, allPages);
    }

    if (filter == null) {
        return allPages;
    }

    return allPages.filter(filter);
}

export async function getTopLevelPages (filter?: PagePredicate | null): Promise<MarkdownInstance<Record<string,any>>[]> {
    const key = 'PageQueries__getTopLevelPages';
    let allPages = await getItem(key);

    if (allPages == null) {
        allPages = await Astro.glob("../pages/*.md");
        await setItem(key, allPages);
    }

    if (filter == null) {
        return allPages;
    }

    return allPages.filter(filter);
}

export async function getAuthorInfo(slug: string) {
    const cacheKey = 'Global__author_info';
    
    let authorInfo = await getItem(cacheKey);

    if (authorInfo == null) {
        const allPages = await Astro.glob("../pages/**/*.md");
        const author = allPages
            .filter(isAuthor)
            .filter(x => x.url?.split('/')[2] == slug)[0];

        authorInfo = {
            frontmatter: author.frontmatter,
            content: author.compiledContent()
        };
  
      await setItem(cacheKey, authorInfo);
    }

    return authorInfo;
}

export async function getTaxonomy() {
    const cacheKey = 'Global__taxonomy';

    type TaxonomyEntry = {
        title: string;
        count: number;
    };

    type Taxonomy = { 
        tags: TaxonomyEntry[];
        topTags: TaxonomyEntry[];
        categories: TaxonomyEntry[];
    };
    
    let taxonomy: Taxonomy = await getItem(cacheKey);

    if (taxonomy == null) {
        const allPages = await getPages();
        const tags: { [key: string]: number } = {};
        const cats: { [key: string]: number } = {};

        // Get taxonomy and counts
        allPages.forEach((p) => {
            p.frontmatter.tags && p.frontmatter.tags.forEach(t => {
                tags[t] = (tags[t] ?? 0) + 1;
            });

            p.frontmatter.categories && p.frontmatter.categories.forEach(c => {
                cats[c] = (cats[c] ?? 0) + 1;
            });
        });

        // Map into the taxonomy
        taxonomy = {
            tags: Object.keys(tags).sort().map(x => {
                return {
                    title: x,
                    count: tags[x]
                };
            }),
            topTags: [],
            categories: Object.keys(cats).sort().map(x => {
                return {
                    title: x,
                    count: cats[x]
                };
            })
        };

        // Get a list of "top tags" by usage count
        const length = Math.min(taxonomy.categories.length, taxonomy.tags.length);
        taxonomy.topTags = taxonomy.tags
            .sort((a, b) => b.count - a.count)
            .slice(0, length)
            .sort((a, b) => {
                if ( a.title < b.title ){
                    return -1;
                }
                if ( a.title > b.title ){
                    return 1;
                }
                return 0;
             });

        await setItem(cacheKey, taxonomy);
    }

    return taxonomy;
}
---